//======================================================================
//  dov-image-viewer.gob - 
//
//  Dov Grobgeld <dov.grobgeld@gmail.com>
//  Sat Aug 25 21:39:53 2007
//----------------------------------------------------------------------
requires 2.0.0

%headertop{
#include <stdlib.h>
#include <gtk/gtk.h>
%}

%{
#define DBG(a) 
#define DBG2(a)

static gint view_changed(DovImageViewer *image_widget,
			 int do_force,
			 double scale_x,
			 double scale_y,
			 double x0,
			 double y0);

static gint zoom_reset(DovImageViewer *self);
static gint zoom_in(DovImageViewer *self, int x, int y);
static gint zoom_out(DovImageViewer *self, int x, int y);
static gint zoom_translate(DovImageViewer *self, int dx, int dy);
static void update_adjustments(DovImageViewer *image_viewer);
static void vadjustment_value_changed (GtkAdjustment *vadjustment,
                                       gpointer       data);
static void hadjustment_value_changed (GtkAdjustment *hadjustment,
                                       gpointer       data);

%}


class Dov:Image:Viewer from Gtk:Widget
{
  private GdkPixbuf *image=NULL;
  private gdouble current_scale_x;
  private gdouble current_scale_y;
  private gint current_x0;
  private gint current_y0;
  private gint canvas_width;
  private gint canvas_height;
  private gboolean do_flip_vertical = false;
  private gboolean do_flip_horizontal = false;
  private gboolean do_use_transfer_map = false;
  private GdkInterpType interp_type = GDK_INTERP_NEAREST;
  private guint8 *transfer_map[3];
  private gboolean do_linear_zoom_steps;
  private gdouble min_zoom;
  private gdouble max_zoom;
  private GdkGC *gc;
  private gdouble scroll_min_x;
  private gdouble scroll_max_x;
  private gdouble scroll_min_y;
  private gdouble scroll_max_y;
  private gdouble scroll_width;
  private gdouble scroll_height;
  private GtkAdjustment *hadjustment = NULL;
  private GtkAdjustment *vadjustment = NULL;
  private gint last_x;
  private gint last_y;
  private gboolean is_mouse_button2_pressed = FALSE;
  private gdouble last_pan_anchor_x;
  private gdouble last_pan_anchor_y;
  private gint button;

  
  init(self)
  {
    GTK_WIDGET_SET_FLAGS (self, GTK_CAN_FOCUS);
    selfp->interp_type = GDK_INTERP_NEAREST;
    selfp->do_linear_zoom_steps = FALSE;
    selfp->do_use_transfer_map = FALSE;
    selfp->do_flip_vertical = FALSE;
    selfp->do_flip_horizontal = FALSE;
    selfp->current_scale_x = 1.0;
    selfp->current_scale_y = 1.0;
    selfp->current_x0 = 0;
    selfp->current_y0 = 0;
    selfp->min_zoom = 1.0/8;
    selfp->max_zoom = 128;
    selfp->scroll_width = -1;
    selfp->scroll_height = -1;
    selfp->gc = NULL;
    selfp->hadjustment = 0;
    selfp->vadjustment = 0;
  }

  class_init(self) {
    // The following statement does the magic of connecting the scrolled_window
    // packing to the scrolling of the image viewer.
    ((GtkWidgetClass*)self)->set_scroll_adjustments_signal = object_signals[SET_SCROLL_ADJUSTMENTS_SIGNAL];
  }
  
  public GtkWidget *
  new (GdkPixbuf *pixbuf)
  {
    DovImageViewer *self = DOV_IMAGE_VIEWER(GET_NEW);

    dov_image_viewer_set_image(self, pixbuf);
    
    return GTK_WIDGET(self);
  }

  public GtkWidget *
  new_from_file (const gchar *filename)
  {
    DovImageViewer *self = DOV_IMAGE_VIEWER(GET_NEW);
    GError *error = NULL;

    if (selfp->image)
      gdk_pixbuf_unref(selfp->image);
    selfp->image = gdk_pixbuf_new_from_file(filename, &error);
    
    return GTK_WIDGET(self);
  }

  override (Gtk:Widget)
  void
  realize (Gtk:Widget *self (check null type))
  {
    GtkWidget *widget = GTK_WIDGET(self);
    GdkWindowAttr attributes;
    gint attributes_mask;
    
    GTK_WIDGET_SET_FLAGS (widget, GTK_REALIZED);
      
    attributes.x = widget->allocation.x;
    attributes.y = widget->allocation.y;
    attributes.width = widget->allocation.width;
    attributes.height = widget->allocation.height;
    attributes.wclass = GDK_INPUT_OUTPUT;
    attributes.window_type = GDK_WINDOW_CHILD;
    attributes.event_mask = gtk_widget_get_events (widget) | 
      GDK_EXPOSURE_MASK |
      GDK_BUTTON_PRESS_MASK | 
      GDK_BUTTON_RELEASE_MASK |
      GDK_POINTER_MOTION_MASK |
      GDK_POINTER_MOTION_HINT_MASK | 
      GDK_KEY_PRESS_MASK |
      GDK_LEAVE_NOTIFY_MASK |
      GDK_ENTER_NOTIFY_MASK;
    attributes.visual = gtk_widget_get_visual (widget);
    attributes.colormap = gtk_widget_get_colormap (widget);
      
    attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
    widget->window = gdk_window_new (widget->parent->window, &attributes, attributes_mask);
      
    widget->style = gtk_style_attach (widget->style, widget->window);
      
    gdk_window_set_user_data (widget->window, widget);
      
    // Force background to be white. This is uggly and should be fixed!
    {
      GdkColor color;
      gdk_color_parse("white", &color);
      gtk_widget_modify_bg(self, GTK_STATE_NORMAL, &color);
      gtk_widget_modify_bg(self, GTK_STATE_ACTIVE, &color);
    }

    //    gtk_style_set_background (widget->style, widget->window, GTK_STATE_ACTIVE);
  }

  override (Gtk:Widget)
  void
  size_request (GtkWidget      *widget,
                GtkRequisition *requisition)
  {
    DovImageViewer *self = DOV_IMAGE_VIEWER (widget);

    if (selfp->image) 
      {
        requisition->width = gdk_pixbuf_get_width(selfp->image);
        requisition->height = gdk_pixbuf_get_height(selfp->image);
      }
    else
      {
        requisition->width = 256;
        requisition->height = 256;
      }
  }
  
  override (Gtk:Widget)
  void 
  size_allocate (GtkWidget     *widget,
                 GtkAllocation *allocation)
  {
    DovImageViewer *self;
    int old_cnv_w, old_cnv_h;
  
    widget->allocation = *allocation;
    self = DOV_IMAGE_VIEWER (widget);
  
    if (GTK_WIDGET_REALIZED (widget))
      {
  
        gdk_window_move_resize (widget->window,
  			      allocation->x, allocation->y,
  			      allocation->width, allocation->height);
  
        
      }
  
    old_cnv_w = GTK_WIDGET(self)->allocation.width;
    old_cnv_h = selfp->canvas_height;
    selfp->canvas_width = widget->allocation.width;
    selfp->canvas_height = widget->allocation.height;
  
    /* Update current_x0 and current_y0 if new size is wider than scale *
     * image size!
     */
    if (selfp->image)
      {
        double scale_x = selfp->current_scale_x;
        double scale_y = selfp->current_scale_y;
        int img_w = (int)(gdk_pixbuf_get_width(selfp->image)*scale_x);
        int img_h = (int)(gdk_pixbuf_get_height(selfp->image)*scale_y);
        int cnv_w = GTK_WIDGET(self)->allocation.width;
        int cnv_h = GTK_WIDGET(self)->allocation.height;
  
        DBG(fprintf(stderr,"Resize: x0 y0 img_w img_h cnv_w cnv_h = %f %f %d %d %d %d\n",
  	      selfp->current_x0,selfp->current_y0,img_w,img_h,cnv_w,cnv_h));
  
        if (cnv_w > img_w)
  	selfp->current_x0 = -(cnv_w-img_w)/2;
        else if (old_cnv_w > img_w)
  	selfp->current_x0 = 0;
        else if (img_w - selfp->current_x0 < cnv_w)
  	{
  	  DBG(fprintf(stderr, "Resize case 3X\n"));
  	  selfp->current_x0 = img_w-cnv_w;
  	}
        if (cnv_h > img_h)
          selfp->current_y0 = -(cnv_h-img_h)/2;
        else if (old_cnv_h > img_h)
          selfp->current_y0 = 0;
        else if (img_h - selfp->current_y0 < cnv_h)
          {
            DBG(fprintf(stderr, "Resize case 3Y\n"));
            selfp->current_y0 = img_h-cnv_h;
          }
      }
  }

  override (Gtk:Widget)
  gint
  expose_event (GtkWidget      *widget,
                GdkEventExpose *event)
  {
    dov_image_viewer_expose_area(DOV_IMAGE_VIEWER(widget),
                                 event->area.x, event->area.y,
                                 event->area.width, event->area.height);
    
    return FALSE;
  }

  override (Gtk:Widget)
  gint
  enter_notify_event(GtkWidget *widget,
                     GdkEventCrossing *event)
  {
    if (!GTK_WIDGET_HAS_FOCUS (widget))
      gtk_widget_grab_focus (widget);
    
    return TRUE;
  }

  override (Gtk:Widget)
  gint
  key_press_event (GtkWidget   *widget,
                   GdkEventKey *event)
  {
    DovImageViewer *self = DOV_IMAGE_VIEWER(widget);
    int ret = TRUE;
    gint k;

    k = event->keyval;
    
    if (k == '=' || k == '>' || k == '+')
      {
        zoom_in(self, selfp->last_x, selfp->last_y);
      }
    else if (k == '<' || k == '-')
      zoom_out(self, 0, 0);
    else if (k == '1' || k == 'n')
      zoom_reset(self);
    else if (k == 'v')
      {
        dov_image_viewer_set_flip(self,
                                  selfp->do_flip_horizontal,
                                  !selfp->do_flip_vertical);
      }
    else if (k == 'h')
      {
        dov_image_viewer_set_flip(self,
                                  !selfp->do_flip_horizontal,
                                  selfp->do_flip_vertical);
      }
    else
      ret = FALSE;
    return ret;
  }

  override (Gtk:Widget)
  gint
  button_press_event (GtkWidget *widget,
                      GdkEventButton *event)
  {
    DovImageViewer *self = DOV_IMAGE_VIEWER(widget);
    int button = event->button;
    double x = event->x;
    double y = event->y;
  
    if (button == 1)
      zoom_in(self, (int)x, (int)y);
    else if (button == 2)
      {
        gtk_grab_add (GTK_WIDGET(self));
        selfp->is_mouse_button2_pressed = TRUE;
        selfp->last_pan_anchor_x = x;
        selfp->last_pan_anchor_y = y;
      }
    else if (button == 3)
      zoom_out(self, (int)x, (int)y);
    
    selfp->button = event->button;
    
    return FALSE;
  }

  override (Gtk:Widget)
  gint
  button_release_event (GtkWidget      *widget,
                        GdkEventButton *event)
  {
    DovImageViewer *self;
    gdouble x = event->x;
    gdouble y = event->y;
  
    g_return_val_if_fail (widget != NULL, FALSE);
    g_return_val_if_fail (DOV_IS_IMAGE_VIEWER (widget), FALSE);
    g_return_val_if_fail (event != NULL, FALSE);
  
    self = DOV_IMAGE_VIEWER (widget);
  
    if (selfp->button == (int)event->button)
      {
        if (selfp->is_mouse_button2_pressed) {
  	selfp->is_mouse_button2_pressed = FALSE;
  	if (selfp->last_pan_anchor_x>0 && selfp->last_pan_anchor_y > 0)
  	    zoom_translate(self,
                           (int)(selfp->last_pan_anchor_x-x),
  			   (int)(selfp->last_pan_anchor_y-y));
  	gtk_grab_remove (GTK_WIDGET(self));
  
  	/* Emit an additional view changed signal at the end of the scrolling
  	   in order to support redrawing only when the panning is done.
  	*/
#if 0
  	gtk_signal_emit(GTK_OBJECT(image_viewer), gtk_image_viewer_signals[VIEW_CHANGED]);
#endif

        }
      }
  
    return FALSE;
  }

  
  /*======================================================================
  //  The motion callback should scroll the image. The current solution
  //  unfortunately does not create smooth scrolling. A further
  //  investigation of how e.g. gimp does it is needed.
  //----------------------------------------------------------------------
  */
  override (Gtk:Widget)
  gint
  motion_notify_event (GtkWidget      *widget,
                       GdkEventMotion *event)
  {
    DovImageViewer *self;
    GdkModifierType state;
    gint x, y;
  
    g_return_val_if_fail (widget != NULL, FALSE);
    g_return_val_if_fail (DOV_IS_IMAGE_VIEWER (widget), FALSE);
    g_return_val_if_fail (event != NULL, FALSE);
  
    self = DOV_IMAGE_VIEWER (widget);
  
    if (event->is_hint) {
       gdk_window_get_pointer(event->window, &x, &y, &state);
    } else {
       x = (int) event->x;
       y = (int) event->y;
    }
    selfp->last_x = x;
    selfp->last_y = y;
  
    if (selfp->is_mouse_button2_pressed)
      {
        if (selfp->last_pan_anchor_x>0 && selfp->last_pan_anchor_y > 0)
  	zoom_translate(self,
                       (int)(selfp->last_pan_anchor_x-x),
  		       (int)(selfp->last_pan_anchor_y-y));
        
        selfp->last_pan_anchor_x = x;
        selfp->last_pan_anchor_y = y;
  
        return TRUE;
      }
    
    return FALSE;
  }

  override (Gtk:Widget)
  gint
  scroll_event (GtkWidget      *widget,
                GdkEventScroll *event)
  {
    DovImageViewer *self = DOV_IMAGE_VIEWER(widget);
    /* Add the following in order only to get control scroll.
    if (event->state & GDK_CONTROL_MASK)
     */
    {
      gdouble x = event->x;
      gdouble y = event->y;
      if (event->direction)
        zoom_in(self, (int)x,(int)y);
      else
        zoom_out(self, (int)x,(int)y);
      return 1;
    }
    return 0;
  }


  public
  void
  expose_area(self,
              int exp_x0, int exp_y0,
              int w, int h)
  {
    GtkWidget *widget = GTK_WIDGET(self); /* In order to access window */
    GdkPixbuf *img_scaled = NULL;
    double scale_x = selfp->current_scale_x;
    double scale_y = selfp->current_scale_y;
    int exp_x1 = exp_x0 + w;
    int exp_y1 = exp_y0 + h;
    int offs_x = -selfp->current_x0-exp_x0;
    int offs_y = -selfp->current_y0-exp_y0;
    int dst_x = exp_x0;
    int dst_y = exp_y0;
    int copy_w = w;
    int copy_h = h;

    if (selfp->image)
      {
  				/* Canvas size */
        int cnv_w = GTK_WIDGET(self)->allocation.width;
        int cnv_h = GTK_WIDGET(self)->allocation.height;
        int img_w, img_h;		/* Image's size (pixels) */
        int img_x0 = 0;
        int img_x1 = cnv_w;
        int img_y0 = 0;
        int img_y1 = cnv_h;
        img_w = gdk_pixbuf_get_width(selfp->image);
        img_h = gdk_pixbuf_get_height(selfp->image);
        DBG(fprintf(stderr, "current_x0 exp_x0 offs_x = %f %d %d\n",
                    selfp->current_x0,
                    exp_x0,
                    offs_x));
  
        /* If img fits in canvas horizontally, need a smaller drawing zone */
        if (img_w * scale_x < cnv_w) 
  	{
  	  img_x0 = (int)((cnv_w - img_w*scale_x)/2);
  	  img_x1 = (int)(img_x0 + img_w*scale_x);
  	}
  
        /* If img fits in canvas vertically : need a smaller drawing zone */
        if (img_h * scale_y < cnv_h)
  	{
  	  img_y0 = (int)((cnv_h - img_h*scale_y)/2);
  	  img_y1 = (int)(img_y0 + img_h*scale_y);
  	}
  
        if (exp_x1 < img_x0)
  	{
  	  DBG(fprintf(stderr, "Case 1X\n"));
  	  copy_w = 0;
  	  offs_x = 0;
  	  dst_x = img_x0;
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0,exp_y0,w, h);
  	}
        else if (exp_x0 < img_x0 && exp_x1 > img_x1)
  	{
  	  DBG(fprintf(stderr, "Case 2X\n"));
  	  copy_w = w - (img_x0 - exp_x0) - (exp_x1 - img_x1);
  	  dst_x = img_x0;
  	  offs_x = 0;
  	  
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0,exp_y0,(img_x0-exp_x0), h);
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     img_x1,exp_y0,(exp_x1-img_x1), h);
  	}
        else if (exp_x0 < img_x0)
  	{
  	  DBG(fprintf(stderr, "Case 3X\n"));
  	  offs_x = 0;
  	  copy_w = w - (img_x0 - exp_x0);
  	  dst_x = img_x0;
  	  
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0,exp_y0,(img_x0-exp_x0), h);
  	}
        else if (exp_x0 > img_x1)
  	{
  	  DBG(fprintf(stderr, "Case 4X\n"));
  	  copy_w = 0;
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0,exp_y0,w, h);
  	  
  	}
        else if (exp_x1 > img_x1)
  	{
  	  DBG(fprintf(stderr, "Case 5X\n"));
  	  copy_w = w - (exp_x1 - img_x1);
  	  dst_x = exp_x0;
  	  offs_x = -(exp_x0-img_x0);
  	  
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     img_x1,exp_y0,exp_x1-img_x1, h);
  	}
        else
  	{
  	  DBG(fprintf(stderr, "Case 6X\n"));
  	  dst_x = exp_x0;
  	  copy_w = w;
  	}
  
        /* Y dir */
        if (exp_y1 < img_y0)
  	{
  	  DBG(fprintf(stderr, "Case 1Y\n"));
  	  copy_h = 0;
  	  offs_y = 0;
  	  dst_x = img_y0;
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0,exp_y0,w, h);
  	}
        else if (exp_y0 < img_y0 && exp_y1 > img_y1)
  	{
  	  DBG(fprintf(stderr, "Case 2Y\n"));
  	  copy_h = h - (img_y0 - exp_y0) - (exp_y1 - img_y1);
  	  dst_y = img_y0;
  	  offs_y = 0;
  	  
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0,exp_y0,w, img_y0-exp_y0);
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0, img_y1,w, exp_y1-img_y1);
  	}
        else if (exp_y0 < img_y0)
  	{
  	  DBG(fprintf(stderr, "Case 3Y\n"));
  	  offs_y = 0;
  	  copy_h = h - (img_y0 - exp_y0);
  	  dst_y = img_y0;
  	  
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0,exp_y0,w,(img_y0-exp_y0));
  	}
        else if (exp_y0 > img_y1)
  	{
  	  DBG(fprintf(stderr, "Case 4Y\n"));
  	  copy_h = 0;
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0,exp_y0,w, h);
  	  
  	}
        else if (exp_y1 > img_y1)
  	{
  	  DBG(fprintf(stderr, "Case 5Y\n"));
  	  copy_h = h - (exp_y1 - img_y1);
  	  dst_y = exp_y0;
  	  offs_y = -(exp_y0-img_y0);
  	  DBG(fprintf(stderr, "copy_h dst_y = %d %d\n", copy_h, dst_y));
  	  gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
  			     TRUE,
  			     exp_x0,img_y1,w,exp_y1-img_y1);
  	}
        else
  	{
  	  DBG(fprintf(stderr, "Case 6Y\n"));
  	  dst_y = exp_y0;
  	  copy_h = h;
  	}
        
  
        DBG(fprintf(stderr, "dst_x dst_y copy_w copy_h offs_x offs_y = %d %d %d %d %f %f\n",
  	      dst_x, dst_y, copy_w, copy_h,
  	      selfp->current_x0, selfp->current_y0));
        /* Scale and copy the image */
        if (copy_w > 0 && copy_h > 0)
          {
            img_scaled = gdk_pixbuf_new(gdk_pixbuf_get_colorspace(selfp->image),
                                        TRUE,
                                        gdk_pixbuf_get_bits_per_sample(selfp->image),
                                        copy_w, copy_h);
  
            if (selfp->do_flip_vertical) 
              offs_y = (int)(-(gdk_pixbuf_get_height(selfp->image) * scale_y + offs_y - copy_h));
            
            if (selfp->do_flip_horizontal) 
              offs_x = (int)(-(gdk_pixbuf_get_width(selfp->image) * scale_x + offs_x - copy_w));
  
  	  /* Check legality */
  	  DBG(fprintf(stderr, "offs_y copy_h scale_y h = %d %d %f %d\n",
  		      offs_y, copy_h, scale_y, img_h));
  	  gdk_pixbuf_scale(selfp->image,
  			   img_scaled,
  			   0,0,
  			   copy_w,
  			   copy_h,
  			   offs_x,
  			   offs_y,
  			   scale_x, scale_y,
  			   selfp->interp_type);
  	  
  	  if (selfp->do_use_transfer_map)
  	    {
  	      /* Assume we are doing 8-bit... */
  	      guint8 *buf_scaled = gdk_pixbuf_get_pixels(img_scaled);
  	      gint w = gdk_pixbuf_get_width(img_scaled);
  	      gint h = gdk_pixbuf_get_height(img_scaled);
  	      gint rs = gdk_pixbuf_get_rowstride(img_scaled);
  	      gint row_idx, col_idx;
  	      guint8 *rmap = selfp->transfer_map[0];
  	      guint8 *gmap = selfp->transfer_map[1];
  	      guint8 *bmap = selfp->transfer_map[2];
  	      
  	      for (row_idx=0; row_idx<h; row_idx++)
  		{
  		  guint8 *p = &buf_scaled[rs*row_idx];
  		  
  		  for (col_idx=0; col_idx<w; col_idx++)
  		    {
  		      *p = rmap[*p]; p++;
  		      *p = gmap[*p]; p++;
  		      *p = bmap[*p]; p++;
  		    }
  		}
  	    }
  
            if (selfp->do_flip_vertical)
              {
                /* Assume we are doing 8-bit... */
                guint8 *buf_scaled = gdk_pixbuf_get_pixels(img_scaled);
                gint w = gdk_pixbuf_get_width(img_scaled);
                gint h = gdk_pixbuf_get_height(img_scaled);
                gint rs = gdk_pixbuf_get_rowstride(img_scaled);
                gint row_idx, col_idx;
                
                for (row_idx=0; row_idx<h/2; row_idx++)
                  {
                    guint8 *ptr1 = buf_scaled+rs * row_idx;
                    guint8 *ptr2 = buf_scaled+rs * (h-row_idx-1);
                    
                    for (col_idx=0; col_idx<w; col_idx++)
                      {
                        guint8 tmp_r = *ptr1;
                        guint8 tmp_g = *(ptr1+1);
                        guint8 tmp_b = *(ptr1+2);
                        guint8 tmp_alpha = *(ptr1+3);
                        *ptr1++ = *ptr2;
                        *ptr1++ = *(ptr2+1);
                        *ptr1++ = *(ptr2+2);
                        *ptr1++ = *(ptr2+3);
                        *ptr2++ = tmp_r;
                        *ptr2++ = tmp_g;
                        *ptr2++ = tmp_b;
                        *ptr2++ = tmp_alpha;
                      }
                  }
              }
            
            if (selfp->do_flip_horizontal)
              {
  	      /* Assume we are doing 8-bit... */
  	      guint8 *buf_scaled = gdk_pixbuf_get_pixels(img_scaled);
  	      gint w = gdk_pixbuf_get_width(img_scaled);
  	      gint h = gdk_pixbuf_get_height(img_scaled);
  	      gint rs = gdk_pixbuf_get_rowstride(img_scaled);
  	      gint row_idx, col_idx, clr_idx;
  	      
                for (col_idx = 0; col_idx < w/2; col_idx++)
                  {
                    for (row_idx = 0; row_idx <h; row_idx++)
                      {
                        int l_idx = row_idx * rs + col_idx*4;
                        int r_idx = row_idx * rs + (w - col_idx - 1)*4;
                        
                        for (clr_idx=0; clr_idx<4; clr_idx++)
                          {
                            guint8 tmp = buf_scaled[l_idx+clr_idx];
                            buf_scaled[l_idx+clr_idx] = buf_scaled[r_idx+clr_idx];
                            buf_scaled[r_idx+clr_idx] = tmp;
                          }
                      }
                  }
              }


  	}
      }

    // If we are working without a background image then create one
    // now for the painting.
    if (!img_scaled)
      {
        img_scaled = gdk_pixbuf_new(GDK_COLORSPACE_RGB,
                                    TRUE,
                                    8,
                                    w, h);
        offs_x = -selfp->current_x0-exp_x0;
        offs_y = -selfp->current_y0-exp_y0;
        dst_x = exp_x0;
        dst_y = exp_y0;
        copy_w = w;
        copy_h = h;

        gdk_pixbuf_fill(img_scaled,
                        0xffffffff);
    }
          
    // Image annotation signal
    {
        GValue ___param_values[6];
        GValue ___return_val;

        int signal_shift_x = offs_x;
        int signal_shift_y = offs_y;
        double signal_scale_x = scale_x;
        double signal_scale_y = scale_y;

        // Flip the scale and shift if we are flipped
        if (selfp->do_flip_horizontal)
          {
            int w = GTK_WIDGET(self)->allocation.width;
            signal_shift_x = selfp->current_x0 + w - exp_x0;
            signal_scale_x = - signal_scale_x;
          }
        if (selfp->do_flip_vertical)
          {
            int h = GTK_WIDGET(self)->allocation.height;
            signal_shift_y = h - selfp->current_y0 - exp_y0;
            signal_scale_y = -signal_scale_y;
          }

              
        memset (&___return_val, 0, sizeof (___return_val));
        memset (&___param_values, 0, sizeof (___param_values));
        
        ___param_values[0].g_type = 0;
        g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
        g_value_set_instance (&___param_values[0], (gpointer) self);
        
        ___param_values[1].g_type = 0;
        g_value_init (&___param_values[1], G_TYPE_POINTER);
        g_value_set_pointer (&___param_values[1], img_scaled);
        
        ___param_values[2].g_type = 0;
        g_value_init (&___param_values[2], G_TYPE_INT);
        g_value_set_int (&___param_values[2], -signal_shift_x);
        
        ___param_values[3].g_type = 0;
        g_value_init (&___param_values[3], G_TYPE_INT);
        g_value_set_int (&___param_values[3], -signal_shift_y);
        
        ___param_values[4].g_type = 0;
        g_value_init (&___param_values[4], G_TYPE_DOUBLE);
        g_value_set_double (&___param_values[4], signal_scale_x);
        
        ___param_values[5].g_type = 0;
        g_value_init (&___param_values[5], G_TYPE_DOUBLE);
        g_value_set_double (&___param_values[5], signal_scale_y);
        
        g_signal_emitv (___param_values,
                        object_signals[IMAGE_ANNOTATE_SIGNAL],
                        0 /* detail */,
                        &___return_val);
        
        for (int i=0; i<6; i++)
            g_value_unset (&___param_values[i]);
    }

    gdk_pixbuf_render_to_drawable (img_scaled,
                                   widget->window,
                                   widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                                   0, 0,
                                   dst_x, dst_y,
                                   copy_w, copy_h,
                                   GDK_RGB_DITHER_NORMAL,
                                   selfp->current_x0,
                                   selfp->current_y0);
    
    gdk_pixbuf_unref(img_scaled);
  
#if 0
    gtk_signal_emit(GTK_OBJECT(self), dov_image_viewer_signals[VIEW_CHANGED]);
#endif
    update_adjustments(self);
  }

  public
  gint
  redraw(self)
  {
    if (GTK_WIDGET(self)->window)
      dov_image_viewer_expose_area(self,
                                   0,0,
                                   GTK_WIDGET(self)->allocation.width,
                                   GTK_WIDGET(self)->allocation.height);
    return FALSE;
  }

  /*======================================================================
  //  gtk_image_viewer_zoom_around_fixed_point is a preprocessor
  //  to view_changed that allows a zooming while moving an old pixel
  //  coordinate to a given new position. E.g. moving the x,y coordinate
  //  clicked by the mouse to the center of the zoomed up image.
  //----------------------------------------------------------------------
  */
  public
  gint
  zoom_around_fixed_point(self,
                          double new_scale_x,
                          double new_scale_y,
                          double old_x,
                          double old_y,
                          double new_x,
                          double new_y)
  {
    double old_scale_x, old_scale_y, old_x0, old_y0, new_x0, new_y0;
    int w = GTK_WIDGET(self)->allocation.width;
    int h = GTK_WIDGET(self)->allocation.height;
    printf("zoom_around_fixed_point: nsx nsy old_x old_y new_x new_y = %f %f  %f %f  %f %f\n",
           new_scale_x, new_scale_y,
           old_x, old_y,
           new_x, new_y);

    g_return_val_if_fail (self != NULL, FALSE);
    g_return_val_if_fail (DOV_IS_IMAGE_VIEWER (self), FALSE);

    /* Short cuts */
    old_x0 = selfp->current_x0;
    old_y0 = selfp->current_y0;
    old_scale_x = selfp->current_scale_x;
    old_scale_y = selfp->current_scale_y;

    if (selfp->do_flip_horizontal)
      {
        old_x0 = w - old_x0;
        old_x = w - old_x;
        new_x = w - new_x;
      }
    if (selfp->do_flip_vertical)
      {
        old_y0 = h - old_y0;
        old_y = h - old_y;
        new_y = h - new_y;
      }
    
      old_y = GTK_WIDGET(self)->allocation.height - old_y;

    new_x0 = new_scale_x/old_scale_x * (old_x + old_x0) - new_x;
    new_y0 = new_scale_y/old_scale_y * (old_y + old_y0) - new_y;
    
    if (selfp->do_flip_horizontal)
      new_x0 = w - new_x0;
    if (selfp->do_flip_vertical)
      new_y0 = h - new_y0;

    view_changed(self, FALSE, new_scale_x, new_scale_y, new_x0, new_y0);
    
    return 0;
  }

  /**
   * gtk_image_viewer_set_hadjustment:
   * @image_viewer: a #DovImage_Viewer.
   * @adjustment: a #GtkAdjustment.
   * 
   * Sets the horizontal adjustment of the image_viewer.
   **/
  public void
  set_hadjustment (self,
                   GtkAdjustment *adjustment)
  {
    g_return_if_fail (DOV_IS_IMAGE_VIEWER (self));
    if (adjustment)
      g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
  
    if (selfp->hadjustment && selfp->hadjustment != adjustment)
      {
        gtk_signal_disconnect_by_data (GTK_OBJECT (selfp->hadjustment), self);
        gtk_object_unref (GTK_OBJECT (selfp->hadjustment));
        selfp->hadjustment = NULL;
      }
  
    if (!adjustment)
      adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 0.0,
  						     0.0, 0.0, 0.0));
  
    if (selfp->hadjustment != adjustment)
      {
        selfp->hadjustment = adjustment;
        gtk_object_ref (GTK_OBJECT (selfp->hadjustment));
        gtk_object_sink (GTK_OBJECT (selfp->hadjustment));
        
        gtk_signal_connect (GTK_OBJECT (adjustment), "value_changed",
  			  G_CALLBACK(hadjustment_value_changed),
  			  (gpointer) self);
      }
  
    //    g_object_notify (G_OBJECT (self), "hadjustment");
  }
  
  /**
   * gtk_image_viewer_set_vadjustment:
   * @image_viewer: a #DovImage_Viewer.
   * @adjustment: a #GtkAdjustment.
   * 
   * Sets the vertical adjustment of the image_viewer.
   **/
  public
  void
  set_vadjustment (self,
                   GtkAdjustment *adjustment)
  {
    g_return_if_fail (DOV_IS_IMAGE_VIEWER (self));
    if (adjustment)
      g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
  
    if (selfp->vadjustment && selfp->vadjustment != adjustment)
      {
        gtk_signal_disconnect_by_data (GTK_OBJECT (selfp->vadjustment), self);
        gtk_object_unref (GTK_OBJECT (selfp->vadjustment));
        selfp->vadjustment = NULL;
      }
  
    if (!adjustment)
      adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 0.0,
  						     0.0, 0.0, 0.0));
  
    if (selfp->vadjustment != adjustment)
      {
        selfp->vadjustment = adjustment;
        gtk_object_ref (GTK_OBJECT (selfp->vadjustment));
        gtk_object_sink (GTK_OBJECT (selfp->vadjustment));
        
        gtk_signal_connect (GTK_OBJECT (adjustment), "value_changed",
  			  G_CALLBACK(vadjustment_value_changed),
  			  (gpointer) self);
      }
  
    // g_object_notify (G_OBJECT (self), "vadjustment");
    update_adjustments(self);
  }

  public
  void
  set_image(self,
            GdkPixbuf *image)
  {
    if (selfp->image)
      gdk_pixbuf_unref(selfp->image);
    selfp->image = image;

    if (image)
      {
        gdk_pixbuf_ref(image);
        selfp->scroll_min_x = 0;
        selfp->scroll_min_y = 0;
        selfp->scroll_width = gdk_pixbuf_get_width(image);
        selfp->scroll_height = gdk_pixbuf_get_height(image);
        selfp->scroll_max_x = selfp->scroll_width;
        selfp->scroll_max_y = selfp->scroll_height;
      }

    dov_image_viewer_redraw(self);
  }

  public
  const GdkPixbuf *
  get_image(self)
  {
    return selfp->image;
  }

  signal last NONE (OBJECT, OBJECT)
  void
  set_scroll_adjustments (self,
                          Gtk:Adjustment    *hadjustment,
                          Gtk:Adjustment    *vadjustment)
  {
    if (selfp->hadjustment != hadjustment)
      dov_image_viewer_set_hadjustment (self, hadjustment);
    if (selfp->vadjustment != vadjustment)
      dov_image_viewer_set_vadjustment (self, vadjustment);
  }

  signal last NONE (POINTER, INT, INT, DOUBLE, DOUBLE)
  void
  image_annotate(self,
                 GdkPixbuf *pixbuf,
                 gint shift_x, gint shift_y,
                 gdouble scale_x, gdouble scale_y);

  signal last NONE (INT, INT)
  void
  flip_changed(self,
               gboolean horizontal_flip,
               gboolean vertical_flip);

  public
  guint
  get_image_width(DovImageViewer *self)
  { 
    return gdk_pixbuf_get_width (selfp->image);
  }
  
  public guint
  get_image_height(DovImageViewer *self)
  { 
    return gdk_pixbuf_get_height (selfp->image);
  }

  public void
  canv_coord_to_img_coord(self,
                          double cx, double cy,
                          // output
                          double* imgx, double* imgy)
  {
    if (selfp->do_flip_horizontal)
      {
        int w = GTK_WIDGET(self)->allocation.width;
        *imgx = (selfp->current_x0+w-cx)/selfp->current_scale_x;
      }
    else
      *imgx=(selfp->current_x0+cx)/selfp->current_scale_x;
    if (selfp->do_flip_vertical)
      *imgy = -(cy-selfp->current_y0-GTK_WIDGET(self)->allocation.height)/selfp->current_scale_y;
    else
      *imgy=(cy+selfp->current_y0)/selfp->current_scale_y;
  }

  public void
  img_coord_to_canv_coord(self,
                          double imgx, double imgy,
                          // output
                          double* canvx, double* canvy)
  {
    if (selfp->do_flip_horizontal)
      {
        int w = GTK_WIDGET(self)->allocation.width;
        *canvx = (selfp->current_x0+w-imgx*selfp->current_scale_x);
      }
    else
      *canvx = imgx*selfp->current_scale_x-selfp->current_x0;
    
    
    if (selfp->do_flip_vertical)
      *canvx = -imgy*selfp->current_scale_y + GTK_WIDGET(self)->allocation.height + selfp->current_y0;
    else
      *canvy = imgy*selfp->current_scale_y-selfp->current_y0;
  }

  public void
  set_zoom_range(self,
                 double min_zoom,
                 double max_zoom)
  {
      selfp->min_zoom = min_zoom;
      selfp->max_zoom = max_zoom;
  }

  public void
  get_scale_and_shift(self,
                      gdouble *scale_x,
                      gdouble *scale_y,
                      gint *shift_x,
                      gint *shift_y)
  {
    *scale_x = selfp->current_scale_x;
    *scale_y = selfp->current_scale_y;
    *shift_x = selfp->current_x0;
    *shift_y = selfp->current_y0;
  }
  
  public void
  set_transfer_map(self,
                   guint8 *rmap,
                   guint8 *gmap,
                   guint8 *bmap)
  {
  }

  public void
  set_scroll_region(self,
                    double x0, double y0,
                    double x1, double y1)
  {
    selfp->scroll_min_x = x0;
    selfp->scroll_max_x = x1;
    selfp->scroll_min_y = y0;
    selfp->scroll_max_y = y1;
    selfp->scroll_width = x1-x0;
    selfp->scroll_height = y1-y0;

    update_adjustments(self);
  }

  public void
  set_flip(self,
           gboolean do_flip_horizontal,
           gboolean do_flip_vertical)
  {
    bool need_signal;

    // Flip adjustments
    if (do_flip_horizontal != selfp->do_flip_horizontal) {
      //***      selfp->hadjustment->value = 1 - selfp->hadjustment->page_size - selfp->hadjustment->value;
      selfp->do_flip_horizontal = do_flip_horizontal;
      gtk_adjustment_value_changed(selfp->hadjustment);
      need_signal = true;
    }
    if (do_flip_vertical != selfp->do_flip_vertical) {
      selfp->vadjustment->value = 1 - selfp->vadjustment->page_size - selfp->vadjustment->value;
      selfp->do_flip_vertical = do_flip_vertical;
      gtk_adjustment_value_changed(selfp->vadjustment);
      need_signal =true;
    }

    if (need_signal)
      {
        // Emit flip signal
        {
          GValue ___param_values[3];
          GValue ___return_val;
          
          memset (&___return_val, 0, sizeof (___return_val));
          memset (&___param_values, 0, sizeof (___param_values));
          
          ___param_values[0].g_type = 0;
          g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
          g_value_set_instance (&___param_values[0], (gpointer) self);
          
          ___param_values[1].g_type = 0;
          g_value_init (&___param_values[1], G_TYPE_INT);
          g_value_set_int (&___param_values[1], selfp->do_flip_horizontal);
          
          ___param_values[2].g_type = 0;
          g_value_init (&___param_values[2], G_TYPE_INT);
          g_value_set_int (&___param_values[2], selfp->do_flip_vertical);
          
          g_signal_emitv (___param_values,
                          object_signals[FLIP_CHANGED_SIGNAL],
                          0 /* detail */,
                          &___return_val);
          
          for (int i=0; i<3; i++)
            g_value_unset (&___param_values[i]);
          
          dov_image_viewer_redraw(self);
        }
      }
  }
}
  
%{
/*======================================================================
//  view_changed does clipping, scrolling and scaling.
//----------------------------------------------------------------------
*/
static gint
view_changed(DovImageViewer *self,
	     int do_force,
	     double scale_x, double scale_y, double x0, double y0)
{
  GtkWidget *widget = GTK_WIDGET(self);
  GdkPixbuf *im;
  int render_width, render_height;
  GdkRectangle expose_rect;

  if (!widget || !widget->window)
    return 0;
  
  g_return_val_if_fail (self != NULL, FALSE);
  g_return_val_if_fail (DOV_IS_IMAGE_VIEWER (self), FALSE);

  widget = GTK_WIDGET(self);

  im = selfp->image; /* A short cut */

  DBG2(g_print("force sx sy x0 y0 = %d %f %f %f %f\n",
	       do_force, scale_x, scale_y, x0, y0));

  /* This should certainly be configurable */
  if (scale_x < 1.0)
    selfp->interp_type = GDK_INTERP_BILINEAR;
  else
    selfp->interp_type = GDK_INTERP_NEAREST;

  /* Clip the scale */
  if (selfp->max_zoom > 0 && scale_x>selfp->max_zoom && scale_y > selfp->max_zoom)
    return 0;
  else if (selfp->min_zoom > 0 && scale_x < selfp->min_zoom && scale_y < selfp->min_zoom)
    return 0;

  /* Clip the request */
  if (im
      || (selfp->scroll_width > 0 && selfp->scroll_height > 0)
      )
    {
      int cwidth = GTK_WIDGET(self)->allocation.width;
      int cheight = GTK_WIDGET(self)->allocation.height;
      double height, width;

      width = selfp->scroll_width;
      height = selfp->scroll_height;

      if (im && width*scale_x > cwidth)
        render_width = cwidth;
      else
        render_width = (int)(width * scale_x);
      
      if (im && height*scale_y > cheight)
	  render_height = cheight;
      else
        render_height = (int)(height * scale_y);

      // Clip only for images
      if (im)
        {
          if (render_width < cwidth)
            x0 = -(cwidth - render_width)/2;
          else if (x0 + render_width > width*scale_x)
            x0 = width*scale_x - render_width;
          else if (x0<0)
            x0 = 0;
          
          if (im && render_height < cheight)
            y0 = -(cheight - render_height)/2;
          else if (y0 + render_height > height*scale_y)
            y0 = height*scale_y - render_height;
          else if (y0<0)
            y0 = 0;
        }
    }

  /* If scale is the same, then the image has only been scrolled,
     and we only need to update the exposed areas.
   */
  if (!do_force
      && widget->window
      && scale_x == selfp->current_scale_x
      && scale_y == selfp->current_scale_y
      )
    {
      int dx = (int)(x0 - selfp->current_x0);
      int dy = (int)(y0 - selfp->current_y0);
      int src_x = (dx < 0) ? 0 : dx;
      int src_y = (dy < 0) ? 0 : dy;
      int dst_x = (dx < 0) ? -dx : 0;
      int dst_y = (dy < 0) ? -dy : 0;

      /* Construct the gc the first time it is used */
      if (!selfp->gc)
        {
	  selfp->gc = gdk_gc_new(widget->window);
	  gdk_gc_copy(selfp->gc, widget->style->white_gc);
	  gdk_gc_set_exposures(selfp->gc, TRUE);
	}

      selfp->current_x0 = (int)x0;
#if 0
      printf("view changed current_x0 dx y0 dy= %d %d %d %d\n",
             selfp->current_x0, dx,
             selfp->current_y0, dy
             );
#endif
      selfp->current_y0 = (int)y0;

      /* Scroll visible region */
      gdk_draw_pixmap (widget->window,
		       selfp->gc,
		       widget->window,
		       src_x, src_y,
		       dst_x, dst_y,
		       GTK_WIDGET(self)->allocation.width - abs (dx),
		       GTK_WIDGET(self)->allocation.height - abs (dy));

      DBG2(g_print("Filling in: dx dy = %d %d\n", dx, dy));
      /* And fill in the new areas */
      if (dx)
	{
	    expose_rect.x = (dx < 0) ? 0 : GTK_WIDGET(self)->allocation.width - dx;
	    expose_rect.y = 0;
	    expose_rect.width = abs(dx);
	    expose_rect.height = GTK_WIDGET(self)->allocation.height;

	    gdk_window_invalidate_rect(widget->window,
				       &expose_rect,
				       FALSE);
	    gdk_window_process_updates(widget->window,
				       FALSE);

	}
      if (dy)
	{
	    expose_rect.x = 0;
	    expose_rect.y = (dy < 0) ? 0 : GTK_WIDGET(self)->allocation.height - dy;;
	    expose_rect.width = GTK_WIDGET(self)->allocation.width;
	    expose_rect.height = abs(dy);

	    gdk_window_invalidate_rect(widget->window,
				       &expose_rect,
				       FALSE);
	    gdk_window_process_updates(widget->window,
				       FALSE);

	}
    }
  
  else if (widget->window &&
	   (do_force
      || scale_x != selfp->current_scale_x
      || scale_y != selfp->current_scale_y
      || x0 != selfp->current_x0
      || y0 != selfp->current_y0))
    {
      /* Remember the current transform */
      selfp->current_scale_x = scale_x;
      selfp->current_scale_y = scale_y;
      selfp->current_x0 = (gint)x0;
      selfp->current_y0 = (gint)y0;

      expose_rect.x = 0;
      expose_rect.y = 0;
      expose_rect.width = GTK_WIDGET(self)->allocation.width;
      expose_rect.height = GTK_WIDGET(self)->allocation.height;

      /* gdk_window_ref (expose_event.window); */
      gdk_window_invalidate_rect(widget->window,
				 &expose_rect,
				 TRUE);
      gdk_window_process_updates(widget->window,
				 TRUE
				 );
    }

  return 1;
}

/*======================================================================
//  Zoom related functions.
//----------------------------------------------------------------------*/
static gint
zoom_reset(DovImageViewer *self)
{
    view_changed(self, TRUE, 1, 1, 0, 0);
    return 1;
}

static gint
zoom_in(DovImageViewer *self, int x, int y)
{
  double zoom_factor[2];
  int zoom_idx;

  zoom_factor[0] = selfp->current_scale_x;
  zoom_factor[1] = selfp->current_scale_y;

  for (zoom_idx = 0; zoom_idx < 2; zoom_idx++)
    {
      double z = zoom_factor[zoom_idx];  /* A shortcut */
      if (selfp->do_linear_zoom_steps) {
	if (z < 0.5)
	  z = 1.0 / (1.0/z-1);
	else
	  z = z+1;
      }
      else 
	z *= 2;
      zoom_factor[zoom_idx] = z;
    }

  dov_image_viewer_zoom_around_fixed_point(self,
					   zoom_factor[0],
					   zoom_factor[1],
					   x, y,
					   GTK_WIDGET(self)->allocation.width/2,
					   GTK_WIDGET(self)->allocation.height/2);

  return 1;
}

static gint
zoom_out(DovImageViewer *self, int x, int y)
{
  double zoom_factor[2];
  int zoom_idx;

  zoom_factor[0] = selfp->current_scale_x;
  zoom_factor[1] = selfp->current_scale_y;

  for (zoom_idx = 0; zoom_idx < 2; zoom_idx++)
    {
      double z = zoom_factor[zoom_idx];  /* A shortcut */
      if (selfp->do_linear_zoom_steps) {
	if (z <= 1.0)
	  z = 1.0 / (1.0/z+1);
	else
	  z = z-1;
      }
      else 
	z /= 2.0;
      zoom_factor[zoom_idx] = z;
    }

  dov_image_viewer_zoom_around_fixed_point(self,
					   zoom_factor[0],
					   zoom_factor[1],
					   GTK_WIDGET(self)->allocation.width/2,
					   GTK_WIDGET(self)->allocation.height/2,
					   GTK_WIDGET(self)->allocation.width/2,
					   GTK_WIDGET(self)->allocation.height/2);
  return 1;
}

static gint
zoom_translate(DovImageViewer *self, int dx, int dy)
{
  view_changed(self,
	       FALSE,
	       selfp->current_scale_x,
	       selfp->current_scale_y,
	       selfp->current_x0+dx,
	       selfp->current_y0+dy);
  return 1;
}


static void
hadjustment_value_changed (GtkAdjustment *hadjustment,
                           gpointer       data)
{
  DovImageViewer *self;
  double min = 0;
  double new_x0, dx;
  double width;

  g_return_if_fail (GTK_IS_ADJUSTMENT (hadjustment));
  g_return_if_fail (DOV_IS_IMAGE_VIEWER (data));

  self = DOV_IMAGE_VIEWER (data);

  width = selfp->scroll_width;
  min = selfp->scroll_min_x;

  // if flip then flip back to calculate same x0 as before flip!
  double v = hadjustment->value;
  double s = selfp->current_scale_x;
  if (selfp->do_flip_horizontal)
    {
      v = 1.0 - hadjustment->page_size - v;
    }
  new_x0 = (v * (width-selfp->hadjustment->page_size) + min) * s;
  dx = new_x0 - selfp->current_x0;

  printf("hadjustment_value_changed: dx = %d\n", (int)dx);
  if ((int)dx!=0) {
    zoom_translate(self, (int)dx, 0);
  }
    
}

static void
vadjustment_value_changed (GtkAdjustment *vadjustment,
                           gpointer       data)
{
  DovImageViewer *self;
  double min = 0;
  double new_y0, dy;
  double height;

  g_return_if_fail (GTK_IS_ADJUSTMENT (vadjustment));
  g_return_if_fail (DOV_IS_IMAGE_VIEWER (data));

  self = DOV_IMAGE_VIEWER (data);

  height = selfp->scroll_height;
  min = selfp->scroll_min_y;

  new_y0 = (vadjustment->value * (height-selfp->vadjustment->page_size) + min) * selfp->current_scale_y;
  dy = new_y0 - selfp->current_y0;

  if ((int)dy!=0) {
#if 0
    printf("vadjustment: value dy = %f %d\n", vadjustment->value, (int)dy);
#endif
    zoom_translate(self, 0, (int)dy);
  }
}

// This function should update the adjustment so that they reflect
// the scrolling of the widget as it was decided somewhere else.
static void update_adjustments(DovImageViewer *self)
{
  double min_x = 0, min_y = 0;
  double width, height;

  if (!selfp->hadjustment
      || !selfp->vadjustment
      )
    return;

  width = selfp->scroll_width;
  height = selfp->scroll_height;
  min_x = selfp->scroll_min_x;
  min_y = selfp->scroll_min_y;

  if (selfp->hadjustment)
    {
      selfp->hadjustment->lower = 0;
      selfp->hadjustment->upper = 1.0;
      selfp->hadjustment->step_increment = 0.01;
      selfp->hadjustment->page_size = GTK_WIDGET(self)->allocation.width / (selfp->scroll_width * selfp->current_scale_x);
      double s = selfp->current_scale_x;
      //***      if (selfp->do_flip_horizontal)
          //***        s = -s;
      selfp->hadjustment->value = (selfp->current_x0/s - selfp->scroll_min_x)/(selfp->scroll_width-selfp->hadjustment->page_size);
      //***      if (selfp->do_flip_horizontal)
          //***        selfp->hadjustment->value = selfp->hadjustment->page_size-selfp->hadjustment->value;

      printf("current_x0 scale ps val = %d %f %f %f\n",
             selfp->current_x0,
             selfp->current_scale_x,
             selfp->hadjustment->page_size,
             selfp->hadjustment->value);

      gtk_adjustment_changed(selfp->hadjustment);
      gtk_adjustment_value_changed(selfp->hadjustment);

    }

  if (selfp->vadjustment)
    {
      selfp->vadjustment->lower = 0;
      selfp->vadjustment->upper = 1.0;
      selfp->vadjustment->step_increment = 0.01;
      
      /* Should be coord of center of image compared to image width */
      //selfp->vadjustment->value = 0.5;
      selfp->vadjustment->value = (selfp->current_y0/selfp->current_scale_y - selfp->scroll_min_y)/(selfp->scroll_height-selfp->vadjustment->page_size);
      selfp->vadjustment->step_increment = 0.01;
      selfp->vadjustment->page_size = GTK_WIDGET(self)->allocation.height / (selfp->scroll_height * selfp->current_scale_y);

      if(0)printf("current_y0 scale ps val = %d %f %f %f\n",
             selfp->current_y0,
             selfp->current_scale_y,
             selfp->vadjustment->page_size,
             selfp->vadjustment->value);

      gtk_adjustment_changed(selfp->vadjustment);
      gtk_adjustment_value_changed(selfp->vadjustment);
    }
}

#if 0
  property OBJECT vadjustment
    (nick = "Vertical adjustment",
     blurb = "Vertical adjustment")
        set { selfp->vadjustment = GTK_ADJUSTMENT(g_value_dup_object (VAL)); }
        get { g_value_set_object (VAL, selfp->vadjustment); }
    ;
  property OBJECT hadjustment
    (nick = "Horizontal adjustment",
     blurb = "Horizontal adjustment")
        set { selfp->hadjustment = GTK_ADJUSTMENT(g_value_dup_object (VAL)); }
        get { g_value_set_object (VAL, selfp->hadjustment); }
    ;

#endif

%}
